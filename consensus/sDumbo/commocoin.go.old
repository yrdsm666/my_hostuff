package sDumbo

import (
	"bytes"
	"context"
	"encoding/hex"
	"encoding/json"
	"errors"
	"github.com/golang/protobuf/proto"
	"github.com/niclabs/tcrsa"
	"github.com/sirupsen/logrus"
	"github.com/syndtr/goleveldb/leveldb"
	go_hotstuff "github.com/wjbbig/go-hotstuff"
	"github.com/wjbbig/go-hotstuff/config"
	"github.com/wjbbig/go-hotstuff/consensus"
	"github.com/wjbbig/go-hotstuff/logging"
	pb "github.com/wjbbig/go-hotstuff/proto"
	"os"
	"strconv"
	"sync"
	
)

var logger = logging.GetLogger()

type CommonCoinImpl struct {
	consensus.AsynchronousImpl
	
	SidStr        string
	MsgEntrance   chan *pb.Msg // receive msg
	cancel        context.CancelFunc
	CoinShare     []*tcrsa.SigShare
	DocumentHash  []byte
	Signature     tcrsa.Signature
}

// sid: session id
func NewCommonCoin(id int, sid int) *ProvableCommonCoinImpl {
	logger.Debugf("[COMMIN COIN] Start Provable Broadcast")
	ctx, cancel := context.WithCancel(context.Background())
	cc := &CommonCoinImpll{
		cancel:        cancel,
	}

	msgEntrance := make(chan *pb.Msg)
	cc.MsgEntrance = msgEntrance
	cc.ID = uint32(id)
	cc.SidStr = strconv.Itoa(sid) + "CommonCoin"
	logger.WithField("replicaID", id).Debug("[COMMIN COIN] Init command cache.")

	// read config
	cc.Config = config.HotStuffConfig{}
	cc.Config.ReadConfig()

	privateKey, err := go_hotstuff.ReadThresholdPrivateKeyFromFile(cc.GetSelfInfo().PrivateKey)
	if err != nil {
		logger.Fatal(err)
	}
	cc.Config.PrivateKey = privateKey

	marshal, _ := json.Marshal(cc.SidStr)
	cc.DocumentHash = marshal
	partSig, _ := go_hotstuff.TSign(marshal, cc.Config.PrivateKey, cc.Config.PublicKey)
	partSigBytes, _ := json.Marshal(partSig)
	coinMsg := bhs.VoteMsg(pb.MsgType_COINSHARE, id, sid, nil, nil)

	// broadcast msg
	cc.Broadcast(coinMsg)

	go cc.receiveMsg(ctx)
	return cc
}

func (cc *ProvableBroadcastImpl) receiveMsg(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			return
		case msg := <-cc.MsgEntrance:
			go cc.handleMsg(msg)
		}
	}
}

func (cc *ProvableBroadcastImpl) handleMsg(msg *pb.Msg) {
	switch msg.Payload.(type) {
	case *pb.Msg_COINSHARE:
		coinShare := msg.GetCoinShare()
		partSig := &tcrsa.SigShare{}
		err := json.Unmarshal(coinShare.PartialSig, partSig)
		if err != nil {
			logger.WithField("error", err.Error()).Error("Unmarshal partSig failed.")
		}

		err := go_hotstuff.VerifyPartSig(partSig, cc.DocumentHash, cc.Config.PublicKey)
		if err != nil {
			logger.WithFields(logrus.Fields{
				"error":        err.Error(),
				"documentHash": hex.EncodeToString(cc.DocumentHash),
			}).Warn("[COMMIN COIN] PBEchoVote: signature not verified!")
			return
		}

		cc.CoinShare = append(cc.CoinShare, partSig)

		if len(cc.CoinShare) == 2*cc.Config.F+1 {
			signature, _ := go_hotstuff.CreateFullSignature(cc.DocumentHash, cc.CoinShare, cc.Config.PublicKey)
			cc.Signature = signature
			cc.cancel()
		} 
		break
	default:
		logger.Warn("Receive unsupported msg")
	}
}
